#########################
# Database Definitions  #
#########################

[[databases]]
name = "oracle_hr"
type = "oracle"
host = "ORACLE_HOST"
port = "1521"
service = "ORCLPDB1"
user = "hr"
password = "secret"

[[databases]]
name = "mysql_inventory"
type = "mysql"
host = "MYSQL_HOST"
port = "3306"
database = "inventory"
user = "inventory_user"
password = "secret"

[[databases]]
name = "sqlite_local"
type = "sqlite"
path = "./data/output.db"

[[databases]]
name = "duckdb_local"
type = "duckdb"
path = "./data/local.duckdb"

#########################
# Task Definitions      #
#########################

[[tasks]]
table_name = "employees"
sql = "SELECT employee_id, first_name, last_name, email, phone_number, hire_date, job_id, salary, department_id FROM employees WHERE department_id = 10"
source_db = "oracle_hr"
target_db = "sqlite_local"
ignore = false
mode = "append"
batch_size = 1000
max_retries = 2
validate = "row_count"
resume_key = "employee_id"
state_file = "./state/db-ferry.json"

[[tasks.indexes]]
name = "idx_employee_id"
columns = ["employee_id"]
unique = true

[[tasks.indexes]]
name = "idx_employee_name"
columns = ["last_name:ASC", "first_name:DESC"]

[[tasks.indexes]]
name = "idx_employee_dept_salary"
columns = ["department_id", "salary:DESC"]

[[tasks]]
table_name = "departments"
sql = "SELECT department_id, department_name, manager_id, location_id FROM departments"
source_db = "oracle_hr"
target_db = "mysql_inventory"
ignore = false

[[tasks.indexes]]
name = "idx_dept_manager"
columns = ["manager_id"]

[[tasks.indexes]]
name = "idx_dept_name_location"
columns = ["department_name:ASC", "location_id:ASC"]
unique = true

[[tasks]]
table_name = "products"
sql = "SELECT product_id, product_name, description, price, created_at, updated_at FROM products WHERE category_id = 5"
source_db = "mysql_inventory"
target_db = "sqlite_local"
ignore = false
mode = "merge"
merge_keys = ["product_id"]

[[tasks.indexes]]
name = "idx_product_id"
columns = ["product_id"]
unique = true

[[tasks.indexes]]
name = "idx_product_name_price"
columns = ["product_name:ASC", "price:DESC"]

[[tasks.indexes]]
name = "idx_product_category"
columns = ["category_id", "price:ASC"]

[[tasks]]
table_name = "archive_orders"
sql = "SELECT * FROM orders WHERE order_date < DATE_SUB(NOW(), INTERVAL 1 YEAR)"
source_db = "mysql_inventory"
target_db = "oracle_hr"
ignore = true

#########################
# Notes                #
#########################
# - Define all source and target databases in the [[databases]] section using unique names (aliases)
# - Each task must specify both source_db and target_db aliases referencing entries from the databases section
# - Supported database types: oracle, mysql, sqlite, duckdb (SQLite/DuckDB only require a path; DuckDB accepts :memory:)
# - Index definitions are optional; order specifiers accept 1/-1 or ASC/DESC
# - Partial indexes (where clause) are only supported for SQLite targets
# - DuckDB connections rely on CGO. Build binaries with CGO_ENABLED=1 if DuckDB aliases are defined.
# - Set ignore = true to temporarily skip a task without removing it
# - mode supports replace (default), append, or merge (upsert)
# - batch_size and max_retries tune insert performance and resilience
# - validate = "row_count" compares inserted rows to target table count (skipped for merge)
# - merge_keys are required for merge mode and should match a unique index on target
# - resume_key + state_file enable incremental/resume; resume_from can override initial start
# - If source_db equals target_db, set allow_same_table = true to acknowledge table drop risk
# - Set skip_create_table = true to keep existing target tables and avoid drop/create
